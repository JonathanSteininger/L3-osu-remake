<!doctype html>

<html>

<head>

  <title>osu!!-maker</title>
  <script src="Maps.js"></script>
</head>
<meta charset="UTF-8">

<body>
  <div>
    <p><button onclick="goFullScreen();">Go Fullscreen</button></p>
    <canvas id="gameCanvas">
      <script>
        var canvas, canvasContext;
        window.onload = function() {
          canvas = document.getElementById("gameCanvas");
          canvasContext = canvas.getContext('2d');
          document.addEventListener('keydown', keyPressed); // sets the event for the keypressed func
          document.addEventListener('keyup', keyReleased); // sets the event for the keyreleased func

          canvas.addEventListener('mousemove', function(evt) { //runs when you move your mouse over the canvas
            var mousePos = getMousePos(canvas, evt);
            mouse[0] = mousePos.x; //used for hover and drag beats
            mouse[1] = mousePos.y;
          }, false);

          canvas.addEventListener("mousedown", function(evt) { //detexts when the mouse has been pressed over canvas
            var mousePos = getMousePos(canvas, evt); //gets the mouse position
            mouse[0] = mousePos.x; //for functions outside
            mouse[1] = mousePos.y; //for functions outside
            beatHitDetect(); //checkes where you hit to what there is to hit
          }, false);
          setInterval(mainloop, 1000 / framesPerSecond);
          resizeCanvas();
          maptimer = 0;
        }

        function goFullScreen() {
          if (canvas.requestFullScreen)
            canvas.requestFullScreen();
          else if (canvas.webkitRequestFullScreen)
            canvas.webkitRequestFullScreen();
          else if (canvas.mozRequestFullScreen)
            canvas.mozRequestFullScreen();
        }

        function mainloop() {
          colourRect(0, 0, canvas.width, canvas.height, "rgb(1,1,1,1)");
          drawmouseline();
          canvasContext.font = "30px Arial";
          canvasContext.fillStyle = "white";
          canvasContext.fillText(maptimer + "time", 100, 100);
        }
        var gamestart = false;
        var framesPerSecond = 60;
        var maptimer = 0;
        var mouse = [0, 0];

        var keyEPressed = false;
        var keyQPressed = false;
        var keySPACEPressed = false;

        const SPACEKEYCODE = 32;
        const EKEYCODE = 69;
        const QKEYCODE = 81;

        var spacereleased = true;
        var spacereleased2 = true;

        var addorminus = 1;

        function keyPressed(evt) { //189
          if (evt.keyCode == SPACEKEYCODE) {
            maptimer += 1 / 60 * addorminus;
          }
          if (evt.keyCode == 49) {
            maptimer += 10 / 60 * addorminus;
          }
          if (evt.keyCode == 50) {
            maptimer += 20 / 60 * addorminus;
          }
          if (evt.keyCode == 51) {
            maptimer += 30 / 60 * addorminus;
          }
          if (evt.keyCode == 52) {
            maptimer += 40 / 60 * addorminus;
          }
          if (evt.keyCode == 53) {
            maptimer += 50 / 60 * addorminus;
          }
          if (evt.keyCode == 54) {
            maptimer += 60 / 60 * addorminus;
          }
          if (evt.keyCode == 55) {
            maptimer += 70 / 60 * addorminus;
          }
          if (evt.keyCode == 56) {
            maptimer += 80 / 60 * addorminus;
          }
          if (evt.keyCode == 57) {
            maptimer += 90 / 60 * addorminus;
          }
          if (evt.keyCode == 48) {
            maptimer += 5 * addorminus;
          }
          if (evt.keyCode == 189) {
            addorminus = -1;
          }
          if (evt.keyCode == EKEYCODE && keyEPressed == false) {
            keyEPressed = true;
            rememberfirstcords();
          }
          if (evt.keyCode == QKEYCODE) {
            dodrag();
          } //49
          if (evt.keyCode == 8) {//backspace
            newmap.pop();
          }
        }

        function keyReleased(evt) {
          if (evt.keyCode == EKEYCODE) {
            if (alldragcordstemp[3].length > 1){

              alldragcordstemp[2] = maptimer - failTimer;
              newmap.push(alldragcordstemp)
              alldragcordstemp = [];
              keyEPressed = false;
              newmap.sort(function(a, b) { //sorts the cart in alphabetical order
                let A = a[1]; // ignore upper and lowercase
                let B = b[1]; // ignore upper and lowercase
                if (A < B) {
                  return -1;
                }
                if (A > B) {
                  return 1;
                }
                return 0;
              });
            }else{
              alldragcordstemp = [];
            }
          }
          if (evt.keyCode == 189) {
            addorminus = 1;
          }
        }
        var alldragcordstemp = []; //[type,starttime,endtime,[allpoints]]

        function rememberfirstcords() {
          alldragcordstemp = [1, maptimer - failTimer, "placeholder", [[mouse[0], mouse[1]]]];
        }

        function dodrag() {
          if (keyEPressed) {
            alldragcordstemp[3].push([mouse[0], mouse[1]]);
          }
        }
        

        function drawmouseline() {
          if (newmap.length > 0) {
            // console.log("running")
            drawallthelines();
            for (let i = 0; i < newmap.length; i++) {
              if (newmap[i][1] + failTimer <= maptimer && newmap[i][1] >= maptimer - failTimer*2 || newmap[i][1] <= maptimer && newmap[i][1]  >= maptimer - failTimer) {
                if (newmap[i][0] == 0) {
                  // console.log("running")
                  if(newmap[i][1] > maptimer-failTimer){
                    colourRect(newmap[i][2][0] - 25, newmap[i][2][1] - 25, 50, 50, "rgb(150,150,150,1)");
                  }else{
                    colourRect(newmap[i][2][0] - 25, newmap[i][2][1] - 25, 50, 50, "rgb(255,255,255,1)");
                  }
                  canvasContext.font = "20px Arial";
                  canvasContext.fillStyle = "black";
                  canvasContext.fillText(newmap[i][1]+2, newmap[i][2][0] - 25, newmap[i][2][1]);
                } else {
                  if(newmap[i][1] > maptimer-failTimer){
                    canvasContext.strokeStyle = "rgb(160,160,160,1)";
                  }else{
                    canvasContext.strokeStyle = "rgb(200,200,200,1)";
                  }
                  canvasContext.lineWidth = 20 * 2;
                  canvasContext.beginPath();
                  canvasContext.moveTo(newmap[i][3][0][0], newmap[i][3][0][1]);
                  for (let ii = 1; ii < newmap[i][3].length; ii++) {
                    canvasContext.lineTo(newmap[i][3][ii][0], newmap[i][3][ii][1]);
                  }
                  canvasContext.stroke()
                  colourRect(newmap[i][3][0][0] - 25, newmap[i][3][0][1] - 25, 50, 50, "rgb(255,255,255,1)");
                  colourRect(newmap[i][3][newmap[i][3].length-1][0] - 25, newmap[i][3][newmap[i][3].length-1][1] - 25, 50, 50, "rgb(255,255,255,1)");
                  canvasContext.font = "20px Arial";
                  canvasContext.fillStyle = "black";
                  canvasContext.fillText(newmap[i][1]+2, newmap[i][3][0][0], newmap[i][3][0][1]);
                  canvasContext.fillText(newmap[i][2]+2, newmap[i][3][newmap[i][3].length-1][0], newmap[i][3][newmap[i][3].length-1][1]);
                }
              }
            }
            // drawallthelines();
          }
          if (keyEPressed) {
            if (alldragcordstemp[3].length >= 2){

              for (let i = 0; i < alldragcordstemp[3].length - 1; i++) {
                drawpath(alldragcordstemp[3][i][0], alldragcordstemp[3][i][1], alldragcordstemp[3][i+1][0], alldragcordstemp[3][i+1][1], 5, "rgb(200,200,200,1)");
              }// 1, 2, [[x,y],[x,y]]
            }
            // console.log(alldragcordstemp,alldragcordstemp[2])//here
            drawpath(alldragcordstemp[3][alldragcordstemp[3].length - 1][0], alldragcordstemp[3][alldragcordstemp[3].length - 1][1], mouse[0], mouse[1], 5, "rgb(200,200,200,1)");
          }
        }

        function drawallthelines() {
          var sc;
          for(let i = 0; i < newmap.length;i++ ){
            if (newmap[i][0] == 0){
              if(newmap[i][1] >= maptimer-failTimer*2){
                sc = i;
                break;
              }
            }else{
              if(newmap[i][2] >= maptimer-failTimer*2){
                sc = i;
                break;
              }
            }
          }
          if (newmap.length > 1) {
            canvasContext.strokeStyle = "rgb(200,200,200,1)";
            canvasContext.lineWidth = 10;
            canvasContext.beginPath();
            if (newmap[sc][0] == 0) {
              canvasContext.moveTo(newmap[sc][2][0], newmap[sc][2][1]);
            } else {
              canvasContext.moveTo(newmap[sc][3][newmap[sc][3].length - 1][0], newmap[sc][3][newmap[sc][3].length - 1][1]);
            }
            for (let iii = sc; iii < newmap.length; iii++) {
              if (newmap[iii][0] == 0) {
                if(newmap[iii][1] <= maptimer){
                  canvasContext.lineTo(newmap[iii][2][0], newmap[iii][2][1]);
                }else{
                  break;
                }
              } else {
                if(newmap[iii][2] <= maptimer){
                  for (let d = 0; d < newmap[iii][3].length-1; d++) {
                    canvasContext.lineTo(newmap[iii][3][d][0], newmap[iii][3][d][1]);
                  }
                }else{
                  break;
                }
              }
            }
            canvasContext.stroke();
          }
        }

        function drawpath(x1, y1, x2, y2, w, c) {
          canvasContext.strokeStyle = c;
          canvasContext.lineWidth = w;
          canvasContext.beginPath();
          canvasContext.moveTo(x1, y1);
          canvasContext.lineTo(x2, y2);
          canvasContext.stroke();
        }

        function startbutton() {
          if (mouse[0] >= canvas.width / 4 && mouse[0] <= canvas.width / 4 * 3 && mouse[1] >= canvas.height / 2 && mouse[1] <= canvas.height / 2 + canvas.height / 5) {
            gamestart = true;
          }
        }
        var newmap = [];

        function beatHitDetect() {
          newmap.push([0, maptimer - failTimer, [mouse[0], mouse[1]]]);
          newmap.sort(function(a, b) { //sorts the cart in alphabetical order
            let A = a[1]; // ignore upper and lowercase
            let B = b[1]; // ignore upper and lowercase
            if (A < B) {
              return -1;
            }
            if (A > B) {
              return 1;
            }
            return 0;
          });
        }

        function resizeCanvas() {
          canvas.width = canvas.clientWidth;
          canvas.height = canvas.clientHeight;
        }

        function drawCircle(x, y, radius, c, borderwidth, bordercolour) {
          canvasContext.strokeStyle = bordercolour;
          canvasContext.lineWidth = borderwidth;
          canvasContext.fillStyle = c;
          canvasContext.beginPath();
          canvasContext.arc(x, y, radius, 0, 2 * Math.PI);
          canvasContext.stroke();
          canvasContext.fill();
        }

        function colourRect(x, y, w, h, c) {
          canvasContext.fillStyle = c;
          canvasContext.fillRect(x, y, w, h)
        }

        function getMousePos(canvas, evt) {
          var rect = canvas.getBoundingClientRect();
          return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
          };
        }
      </script>
    </canvas>
  </div>
</body>

</html>

<style>
  div {
    width: 1920px;
    height: 1920px;
    position: relative;
  }

  canvas {
    position: absolute;
    padding: 0;
    margin: 0;
    width: 100%;
    height: 56.25%;
  }

  * {
    margin: 0;
    padding: 0;
  }

  html {
    overflow-y: hidden;
  }

  button {
    width: 100vw;
    height: 50vh;
    margin-bottom: 50vw;
    font-size: 5vw;
  }
</style>
