<!doctype html>

<html>

<head>

  <title>osu!!</title>
  <script src="Maps.js"></script>
</head>
<meta charset="UTF-8">

<body>
  <div id="canvasContainer">
    <!-- button required to go fullscreen. needs client imput -->
    <p><button onclick="goFullScreen();">Go Fullscreen</button></p>
    <canvas id="gameCanvas">
      <script>
        var canvas, ctx;
        window.onload = function() { //runs when the page loads
          canvas = document.getElementById("gameCanvas");
          ctx = canvas.getContext('2d');

          canvas.addEventListener("mousedown", function(evt) { //detexts when the mouse has been pressed over canvas
            var mousePos = getMousePos(canvas, evt); //gets the mouse position
            mouseDown = true; //for all other functions
            mouse[0] = mousePos.x; //for functions outside
            mouse[1] = mousePos.y; //for functions outside
            buttons(); //checkes where you hit to what there is to hit
          }, false);
          canvas.addEventListener("mouseup", function(evt) { //detects when the mouse is released
            mouseDown = false;
          }, false);

          canvas.addEventListener('mousemove', function(evt) { //runs when you move your mouse over the canvas
            var mousePos = getMousePos(canvas, evt);
            mouse[0] = mousePos.x; //used for hover and drag beats
            mouse[1] = mousePos.y;
          }, false);

          gamerun(); //creats variables
          setInterval(mainloop, 1000 / framesPerSecond); //runs the canvas
          resizeCanvas(); //changes the sizes of the canvas to the screensize of client
        } //func end

        function goFullScreen() { //makes the screen go into fullscreen
          if (canvas.requestFullScreen) {
            canvas.requestFullScreen();
          } else if (canvas.webkitRequestFullScreen) {
            canvas.webkitRequestFullScreen();
          } else if (canvas.mozRequestFullScreen) {
            canvas.mozRequestFullScreen();
          }
        }

        function mainloop() { //mainloop
          colourRect(0, 0, canvas.width, canvas.height, "rgb(50,50,50,1)"); //background
          if (gamestate == "playing") { //if the game has started
            if (currentMap.length <= 0 && beats.length <= 0) { //if the level is finished
              console.log(score);
              gamestate = "mainMenu";
              mapTimer = 0;
              score = 0;
            }
            mapTimer += 1 / framesPerSecond;
            nextBeat();
            nextpaths();
            drawcurrentlines()
            if (beats.length > 0) {
              drawCurrentBeats();
            }
          } else if (gamestate == "mainMenu") {
            //here
            drawMainMenueScreen();
          } else if (gamestate == "paused") {
            drawPauseScreen();
          }
        }//mainloop end

        //mouse
        var mouseDown = false;
        var mouse = [0, 0];

        //game
        var score = 0;
        // var gamestart = false;
        var framesPerSecond = 60;
        var mapTimer = 0;
        var DefaultBeatTime = 30;

        //lines info
        var lineConnectionColour1 = "rgb(255,255,255,0.5)";
        var lineConnectionColour2 = "rgb(255,255,255,0)";
        var lineConnectionwidth = 3;
        var linegradientstrength = 0;
        //lines storage
        var currentlinepos = []; //[line,line,line]//line= [time,[xpos,ypos],timer]
        var linenextcounter = [];
        var currentlines = [];

        //beats and maps
        var failTimer;
        var currentMap = [];
        var beats = [];
        var testing = ["this", 4, "that", 34];

        var gamestate = "mainMenu";
        var lineSmoothness = 10; //smaller = smoother

        var tension = 0.5;

        function getCurvePoints(pts, tension = 0.7, isClosed = false, numOfSegments = 30) {//https://www.xspdf.com/help/50436612.html
          var _pts = [],
            res = [], // clone array
            x, y, // our x,y coords
            t1x, t2x, t1y, t2y, // tension vectors
            c1, c2, c3, c4, // cardinal points
            st, t, i; // steps based on num. of segments

          // clone array so we don't change the original
          _pts = JSON.parse(JSON.stringify(pts));
          // The algorithm require a previous and next point to the actual point array.
          // Check if we will draw closed or open curve.
          // If closed, copy end points to beginning and first points to end
          // If open, duplicate first points to befinning, end points to end
          if (isClosed) {
            _pts.unshift(pts[pts.length - 1]);
            _pts.unshift(pts[pts.length - 1]);
            _pts.push(pts[0]);
          }
          else { //[10, 10, 40, 30, 100, 10, 200, 100, 200, 50, 250, 120]
            _pts.unshift(pts[0]); //copy 1. point and insert at beginning
            _pts.push(pts[pts.length - 1]); //copy last point and append
          } //[10, 10, 10, 10, 40, 30, 100, 10, 200, 100, 200, 50, 250, 120, 250, 120]
          // 1. loop goes through point array
          // 2. loop goes through each segment between the 2 pts + 1e point before and after
          for (i = 1; i < (_pts.length - 2); i += 1) {
            for (t = 0; t <= numOfSegments; t++) {
              // [[10, 10], [10, 10], [40, 30], [100, 10], [200, 100], [200, 50], [250, 120], [250, 120]]
              // calc tension vectors
              // ._,_. ;point ahead - point behind * tension
              //,_._. ; 2 points ahead - current point * tension
              t1x = (_pts[i + 1][0] - _pts[i - 1][0]) * tension; // 100 - 10*0.5
              t2x = (_pts[i + 2][0] - _pts[i][0]) * tension; // 200 - 40*0.5
              t1y = (_pts[i + 1][1] - _pts[i - 1][1]) * tension; //  10 - 10*0.5
              t2y = (_pts[i + 2][1] - _pts[i][1]) * tension; // 100 - 30*0.5
              // calc step
              st = t / numOfSegments; //30 // what stage of the line its at
              // calc cardinals
              c1 = 2 * Math.pow(st, 3) - 3 * Math.pow(st, 2) + 1; //2*0.33^3 - 3 * 0.33^2 + 1 | -5       ;  0.5      ;  0.84375
              c2 = -(2 * Math.pow(st, 3)) + 3 * Math.pow(st, 2);//-1*(2*1^3) + 3*1^2          |  1       ;  0.5      ;  0.15625
              c3 = Math.pow(st, 3) - 2 * Math.pow(st, 2) + st;// 1^3 -2*1^2 +1                |  0       ;  0.125    ;  0.140625
              c4 = Math.pow(st, 3) - Math.pow(st, 2);//1^3 - 1^2                              |  0       ; -0.125    ; -0.046875
              // calc x and y cords with common control vectors
              x = c1*_pts[i][0] + c2*_pts[i + 1][0] + c3*t1x + c4*t2x;// 0.5*xpos + 0.5*nextxpos + 0.125*t1x + -0.125*tx2
              y = c1*_pts[i][1] + c2*_pts[i + 1][1] + c3*t1y + c4*t2y;// 0.5*ypos + 0.5*nextypos + 0.125*t1y + -0.125*ty2
              //store points in array
                res.push([x, y]);
            }
          }
          return res;
        }

        function makeSmoothDragCords(){
          for(let i = 0; i < currentMap.length;i++){
            if (currentMap[i][0] == 1){
              let placeholder = getCurvePoints(currentMap[i][3]);
              currentMap[i][3] = JSON.parse(JSON.stringify(placeholder));
            }

          }
        }//func end

        function drawPauseScreen() {


        } //( x - h )^2 + ( y - k )^2 = r^2,

        var circleXpos;
        var circleYpos;
        var circlesize;
        var mainMenubuttonYend1;
        var mainMenubuttonYstart3;

        function drawMainMenueScreen(hover) {
          circleXpos = canvas.width / 2;
          circleYpos = canvas.height / 3 * 2;
          circlesize = canvas.width / 6;
          //find radieans to a third of circle height
          let intercepty = (circleYpos - circlesize) + (circlesize * 2 / 3);
          let interceptx = circleXpos + Math.sqrt(Math.pow(circlesize, 2) - Math.pow(intercepty - circleYpos, 2));
          let interceptx2 = circleXpos - Math.sqrt(Math.pow(circlesize, 2) - Math.pow(intercepty - circleYpos, 2));
          let length = interceptx - interceptx2;
          let length2 = Math.sqrt(Math.pow(Math.abs(interceptx - circleXpos), 2) + Math.pow(Math.abs(intercepty - circleYpos), 2));
          let angle = Math.acos((Math.pow(length2, 2) + Math.pow(length2, 2) - Math.pow(length, 2)) / (2 * length2 * length2)); //radians

          //borderline inside button locations
          let line1x = circleXpos + calculateCircleFromRadsX(circlesize, (1.5 * Math.PI) + (angle / 2));
          let line1x2 = circleXpos + calculateCircleFromRadsX(circlesize, (1.5 * Math.PI) - (angle / 2));
          mainMenubuttonYend1 = circleYpos + calculateCircleFromRadsY(circlesize, (1.5 * Math.PI) + (angle / 2));
          let line2x = circleXpos + calculateCircleFromRadsX(circlesize, (0.5 * Math.PI) + (angle / 2));
          let line2x2 = circleXpos + calculateCircleFromRadsX(circlesize, (0.5 * Math.PI) - (angle / 2));
          mainMenubuttonYstart3 = circleYpos + calculateCircleFromRadsY(circlesize, (0.5 * Math.PI) + (angle / 2));

          //style of buttons
          let hovergradcolour = ["rgb(215,0,0,1)", "rgb(150,0,0,1)"];
          let normalgradcolour = ["rgb(255,0,0,1)", "rgb(190,0,0,1)"];
          let outlinecolour = "black";
          let outlinewidth = 4;
          let buttoncolour1 = ctx.createRadialGradient(circleXpos, circleYpos, canvas.width / 20, circleXpos, circleYpos, circlesize);
          let buttoncolour2 = ctx.createRadialGradient(circleXpos, circleYpos, canvas.width / 20, circleXpos, circleYpos, circlesize);
          let buttoncolour3 = ctx.createRadialGradient(circleXpos, circleYpos, canvas.width / 20, circleXpos, circleYpos, circlesize);
          if (circlehitboxdetect(circleXpos, circleYpos, mouse[0], mouse[1],circlesize)) {
            if (mouse[1] <= mainMenubuttonYend1) {
              buttoncolour1.addColorStop(0, hovergradcolour[0]);
              buttoncolour1.addColorStop(1, hovergradcolour[1]);
              buttoncolour2.addColorStop(0, normalgradcolour[0]);
              buttoncolour2.addColorStop(1, normalgradcolour[1]);
              buttoncolour3.addColorStop(0, normalgradcolour[0]);
              buttoncolour3.addColorStop(1, normalgradcolour[1]);

            } else if (mouse[1] <= mainMenubuttonYstart3) {
              buttoncolour1.addColorStop(0, normalgradcolour[0]);
              buttoncolour1.addColorStop(1, normalgradcolour[1]);
              buttoncolour2.addColorStop(0, hovergradcolour[0]);
              buttoncolour2.addColorStop(1, hovergradcolour[1]);
              buttoncolour3.addColorStop(0, normalgradcolour[0]);
              buttoncolour3.addColorStop(1, normalgradcolour[1]);
            } else {
              buttoncolour1.addColorStop(0, normalgradcolour[0]);
              buttoncolour1.addColorStop(1, normalgradcolour[1]);
              buttoncolour2.addColorStop(0, normalgradcolour[0]);
              buttoncolour2.addColorStop(1, normalgradcolour[1]);
              buttoncolour3.addColorStop(0, hovergradcolour[0]);
              buttoncolour3.addColorStop(1, hovergradcolour[1]);
            }
          } else {
            buttoncolour1.addColorStop(0, normalgradcolour[0]);
            buttoncolour1.addColorStop(1, normalgradcolour[1]);
            buttoncolour2.addColorStop(0, normalgradcolour[0]);
            buttoncolour2.addColorStop(1, normalgradcolour[1]);
            buttoncolour3.addColorStop(0, normalgradcolour[0]);
            buttoncolour3.addColorStop(1, normalgradcolour[1]);
          }
          ctx.strokeStyle = outlinecolour;
          ctx.lineWidth = outlinewidth;
          //top button
          ctx.fillStyle = buttoncolour1;
          ctx.beginPath();
          ctx.arc(circleXpos, circleYpos, circlesize, (1.5 * Math.PI) - (angle / 2), 1.5 * Math.PI + (angle / 2));
          ctx.stroke();
          ctx.fill();
          //middle button
          ctx.fillStyle = buttoncolour2;
          ctx.beginPath();
          ctx.arc(circleXpos, circleYpos, circlesize, 0.5 * Math.PI + (angle / 2), (1.5 * Math.PI) - (angle / 2));
          ctx.arc(circleXpos, circleYpos, circlesize, 1.5 * Math.PI + (angle / 2), 0.5 * Math.PI - (angle / 2));
          ctx.stroke();
          ctx.fill();
          //bottom button
          ctx.fillStyle = buttoncolour3;
          ctx.beginPath();
          ctx.arc(circleXpos, circleYpos, circlesize, 0.5 * Math.PI - (angle / 2), 0.5 * Math.PI + (angle / 2));
          ctx.stroke();
          ctx.fill();
          //line 1
          ctx.beginPath();
          ctx.moveTo(line1x, mainMenubuttonYend1);
          ctx.lineTo(line1x2, mainMenubuttonYend1)
          ctx.stroke();
          //line2
          ctx.beginPath();
          ctx.moveTo(line2x, mainMenubuttonYstart3);
          ctx.lineTo(line2x2, mainMenubuttonYstart3)
          ctx.stroke();

          ctx.fillStyle = "black";
          ctx.font = canvas.width / 30 + "px Arial";
          ctx.textAlign = "center";
          let tempagainy = mainMenubuttonYend1 - ((mainMenubuttonYend1 - (circleYpos - circlesize)) * 0.3);
          ctx.fillText("Play", circleXpos, tempagainy);
        }

        function calculateCircleFromRadsX(raDius, radians) {
          let tempX = raDius * Math.cos(radians);
          return tempX;
        }

        function calculateCircleFromRadsY(raDius, radians) {
          let tempY = raDius * Math.sin(radians);
          return tempY;
        }

        function buttons() {
          if (gamestate == "mainMenu") {
            if (circlehitboxdetect(circleXpos, circleYpos, mouse[0], mouse[1],circlesize) && mouseDown) {
              if (mouse[1] <= mainMenubuttonYend1) { //top button
                gamestate = "playing";
                gamerun();

              } else if (mouse[1] <= mainMenubuttonYstart3) { //middle button

              } else { //bottom button

              }
            }
          }
          if (gamestate == "playing") {
            if (beats.length > 0) {
              beatHitDetect();
            }
          }
          if (gamestate == "paused") {

          }
        }

        var health = 1000;
        const MAX_HEALTH = 1000;

        function health(){
          if (health <= 0){
            loseMap();
            return;
          }else if (health < MAX_HEALTH){
            health += 60/framesPerSecond;
          }
          let percentage = health / MAX_HEALTH;
          colourRect()
        }

        function loseMap(){

        }












        function makelines() {
          currentlinepos = [];
          currentlines = [];
          linenextcounter = [];
          for (let i = 0; i < currentMap.length; i++) {
            currentlinepos.push([]);
            currentlines.push([]);
            linenextcounter.push([0, 0]);

            if (currentMap[i][0] == 0) {
              if (i == 0) {
                makelinepoint(canvas.width / 2, canvas.height / 2, 0, currentMap[i][2][0], currentMap[i][2][1], currentMap[i][1], i);
              } else {
                if (currentMap[i - 1][0] == 0) {
                  makelinepoint(currentMap[i - 1][2][0], currentMap[i - 1][2][1], currentMap[i - 1][1], currentMap[i][2][0], currentMap[i][2][1], currentMap[i][1], i);
                } else {
                  makelinepoint(currentMap[i - 1][3][currentMap[i - 1][3].length - 1][0], currentMap[i - 1][3][currentMap[i - 1][3].length - 1][1], currentMap[i - 1][2], currentMap[i][2][0],
                    currentMap[i][2][1], currentMap[i][1], i);
                }
              }
            } else {
              if (i == 0) {
                makelinepoint(canvas.width / 2, canvas.height / 2, 0, currentMap[i][3][0][0], currentMap[i][3][0][1], currentMap[i][1], i);
              } else {
                if (currentMap[i - 1][0] == 0) {
                  console.log(currentMap[i - 1][2][0], currentMap[i - 1][2][1], currentMap[i - 1][1], currentMap[i][3][0][0], currentMap[i][3][0][1], currentMap[i][2], i)
                  makelinepoint(currentMap[i - 1][2][0], currentMap[i - 1][2][1], currentMap[i - 1][1], currentMap[i][3][0][0], currentMap[i][3][0][1], currentMap[i][2], i);
                  makelinepoint(currentMap[i - 1][2][0], currentMap[i - 1][2][1], currentMap[i - 1][1], currentMap[i][3][0][0], currentMap[i][3][0][1], currentMap[i][2], i);
                } else {
                  makelinepoint(currentMap[i - 1][3][0][0], currentMap[i - 1][3][0][1], currentMap[i - 1][2], currentMap[i][3][0][0], currentMap[i][3][0][1], currentMap[i][1], i);
                }
              }
            }
          }
        }

        function makelinepoint(x0, y0, t0, x1, y1, t1, mainCounter) {
          let amountofFrames = Math.sqrt(Math.pow(Math.abs(x0 - x1), 2) + Math.pow(Math.abs(y0 - y1), 2)) / lineSmoothness;
          let yintercept69 = y0 - (((y1 - y0) / (x1 - x0)) * x0);
          for (let ii = 0; ii < amountofFrames; ii++) {
            let time = t0 + (((t1 - t0) / amountofFrames) * ii);
            let xpos = x0 + (((x1 - x0) / amountofFrames) * ii);
            let ypos = (((y1 - y0) / (x1 - x0)) * xpos) + yintercept69;
            currentlinepos[mainCounter].push([time, [xpos, ypos], 0]);
          }
        }

        function nextpaths() {
          for (let ii = 0; ii < currentlinepos.length; ii++) {
            for (let i = linenextcounter[ii][1]; i < currentlinepos[ii].length; i++) {
              if (currentlinepos[ii][0][0] <= mapTimer) {
                if (currentlinepos[ii][i][0] <= mapTimer) {
                  if (linenextcounter[ii][1] == 0) {
                    currentlines[ii].push(currentlinepos[ii][0][1], currentlinepos[ii][1][1]);
                  }
                  linenextcounter[ii][1] = i;
                }
              }
            }
            if (currentlines[ii].length > 0) {
              for (let b = 0; b <= 1; b++) {
                if (currentlines[ii][b] != currentlinepos[ii][linenextcounter[ii][b]][1]) {
                  currentlines[ii][b] = currentlinepos[ii][linenextcounter[ii][b]][1];
                }
              }
            }
            if (linenextcounter[ii][1] > 0) {
              for (let i = linenextcounter[ii][0]; i < linenextcounter[ii][1]; i++) {
                currentlinepos[ii][i][2] += 1 / framesPerSecond;
                if (currentlinepos[ii][i][2] >= failTimer) {
                  linenextcounter[ii][0] = i + 1;
                }
              }
            }
          }
        }

        function drawcurrentlines() {
          for (let i = 0; i < currentlines.length; i++) {
            if (currentlines[i].length > 0) {
              drawpath(currentlines[i][0][0], currentlines[i][0][1], currentlines[i][1][0], currentlines[i][1][1], lineConnectionColour1, lineConnectionColour2, lineConnectionwidth, currentlinepos[i][0][1], currentlinepos[i][
                currentlinepos[i].length - 1
              ][1], linegradientstrength)
            }
          }
        }

        function drawpath(x1, y1, x2, y2, c1, c2, w, grdxy1, grdxy2, gradstrength) {
          // let grd = ctx.createRadialGradient(200, 200, 0, 200, 200, 200);//x,y,centergrad radius,outsideX,outsideY, radius.
          let xcenter = (grdxy1[0] - grdxy2[0]) / 2 + grdxy2[0];
          let ycenter = (grdxy1[1] - grdxy2[1]) / 2 + grdxy2[1];
          let radius = Math.sqrt(Math.pow(Math.abs(grdxy1[0] - grdxy2[0]), 2) + Math.pow(Math.abs(grdxy1[1] - grdxy2[1]), 2)) / 2;
          let grd = ctx.createRadialGradient(xcenter, ycenter, 0, xcenter, ycenter, radius); //
          grd.addColorStop(0, c1);
          grd.addColorStop(1, c2);
          ctx.strokeStyle = grd;
          ctx.lineWidth = w;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.closePath();
          ctx.stroke();
        }

        function nextBeat() {
          if (currentMap.length <= 0) {
            return;
          }
          if (mapTimer >= currentMap[0][1]) {
            beats.push(currentMap[0]);
            currentMap.shift();
            score
          }
        }

        function gamerun() {
          currentMap = JSON.parse(JSON.stringify(newestmap[2]));
          failTimer = JSON.parse(JSON.stringify(newestmap[1]));
          beats = [];
          currentlines = [];
          makeSmoothDragCords();
          makelines();
          removedcounter = 0;
        }

        function makegradientforballs(x, y, colour, colour2) {
          returnvar = ctx.createRadialGradient(x, y, defaultBeat.radius / 3, x, y, defaultBeat.radius);
          returnvar.addColorStop(0, colour);
          returnvar.addColorStop(1, colour2);
          return returnvar;

        }
       
        function drawCurrentBeats() {
          if (beats[0][0] == 0) {
            if (beats[0][1] + failTimer <= mapTimer) {
              beats.shift();
            }
          } 
          beats.forEach(Element => {
            if (Element[0] == 0) {
              if (Element[1] < mapTimer) {//here?
                let colourforring = "rgb(255,255,255," + (mapTimer - (Element[1])) * 0.25 + ")"
                let sizeforring = defaultBeat.radius + 3 * (defaultBeat.radius * (Element[1]+ failTimer - mapTimer)/2);
                drawCircle(Element[2][0], Element[2][1], Math.abs(sizeforring), "rgb(0,0,0,0)", defaultBeat.Bordersize, colourforring, 0, 2);
              }
              drawCircle(Element[2][0], Element[2][1], defaultBeat.radius, makegradientforballs(Element[2][0], Element[2][1], defaultBeat.colourstart, defaultBeat.colourend), defaultBeat.Bordersize, defaultBeat.BorderColour, 0,
                2);
            } else {
              drawdragbackground(Element[3], Element[1], Element[2], Element[4],"rgb(100,100,100,1)",2);
              drawdragbackground(Element[3], Element[1], Element[2], Element[4],"rgb(70,70,70,1)");
              dragFunction(Element[3], Element[1], Element[2], Element[4]);
            }
          });
        }

        function dragFunction(pts, time1 ,time2, timeoffset = 0){
          if (dragstart || time1 + failTimer <= mapTimer){
            let amountOfPoints = (time2 - time1)*framesPerSecond;
            let currentpoint;
            if(timeoffset == null){
              currentpoint = ((mapTimer - (time1+failTimer))+ timeoffset )*framesPerSecond/amountOfPoints;
            }else{
              currentpoint = timeoffset*framesPerSecond/amountOfPoints;
              beats[0][4] += 1/framesPerSecond;
            }
            let totalLength = linelengthcalc(pts);
            if (currentpoint >= 1){
              dragComplete();
              return;
            }
            let currentDistance = totalLength*currentpoint;

            //location on line
            var tempjhnfkajn = 0;
            var between = [];
            for(let i = 1; i < pts.length-1; i++){
              if (tempjhnfkajn + Math.sqrt(Math.abs(Math.pow(pts[i+1][0]-pts[i][0],2)) + Math.abs(Math.pow(pts[i+1][1]-pts[i][1],2))) >= currentDistance){
                if (pts[i-1][0] == pts[i][0] && pts[i-1][1] == pts[i][1]){
                  continue;
                }
                if (i-1 < 0){
                  between.push(i,i+1);
                }else{
                  between.push(i-1,i);
                }
                break;
              }else{
                tempjhnfkajn += Math.sqrt(Math.abs(Math.pow(pts[i+1][0]-pts[i][0],2)) + Math.abs(Math.pow(pts[i+1][1]-pts[i][1],2)));
              }
            }//for end
            let rise = (pts[between[1]][1] - pts[between[0]][1]) / (Math.abs(pts[between[1]][1] - pts[between[0]][1]) + Math.abs(pts[between[1]][0] - pts[between[0]][0]));
            let run = (pts[between[1]][0] - pts[between[0]][0]) / (Math.abs(pts[between[1]][1] - pts[between[0]][1]) + Math.abs(pts[between[1]][0] - pts[between[0]][0]));
            let change = currentDistance - tempjhnfkajn;
            
            let pointx = pts[between[0]][0] + (change*run);
            let pointy = pts[between[0]][1] + (change*rise);
            drawCircle( pointx, pointy, defaultBeat.radius, makegradientforballs(pointx, pointy, defaultBeat.colourstart, defaultBeat.colourend), defaultBeat.Bordersize,
                  defaultBeat.BorderColour, 0, 2)
                  if(circlehitboxdetect(pointx,pointy,mouse[0],mouse[1],defaultBeat.radius) && mouseDown){
                    score += 1/framesPerSecond;
                    console.log("nani")
                  }
          }else{
            drawCircle( pts[0][0], pts[0][1], defaultBeat.radius, makegradientforballs(pts[0][0], pts[0][1], defaultBeat.colourstart, defaultBeat.colourend), defaultBeat.Bordersize,
                  defaultBeat.BorderColour, 0, 2)
          }
          colourRect(1034.1273597997385-20, 211.66806936615617-20, 40,40,"rgb(255,255,255,1)")
        }//func end
        
        function linelengthcalc(pts){
          let total = 0;
          for(let i = 0; i < pts.length-1; i++){//a2+b2=c2
            total += Math.sqrt(Math.abs(Math.pow(pts[i+1][0] - pts[i][0],2)) + Math.abs(Math.pow(pts[i+1][1] - pts[i][1],2)));
          }
          return total;
        }//func end

        function drawdragbackground(pts, time1 ,time2, timeoffset = 0, colour, speedMultiplier = 1){
            let amountOfPoints = (time2 - time1)*framesPerSecond;
            var currentpoint = ((mapTimer - (time1)))*framesPerSecond/amountOfPoints*speedMultiplier;
            let totalLength = linelengthcalc(pts);
            if (currentpoint > 1){
              currentpoint = 1;
            }
            let currentDistance = totalLength*currentpoint;

            //location on line
            var tempjhnfkajn = 0;
            var between = [];

            for(let i = 0; i < pts.length-1; i++){
              if (tempjhnfkajn + Math.sqrt(Math.abs(Math.pow(pts[i+1][0]-pts[i][0],2)) + Math.abs(Math.pow(pts[i+1][1]-pts[i][1],2))) >= currentDistance){
                if (pts[i-1][0] == pts[i][0] && pts[i-1][1] == pts[i][1]){
                  console.log("nono")
                  continue;
                }
                if (i-1 < 0){
                  between.push(i,i+1);
                }else{
                  between.push(i-1,i);
                }
                break;
              }else{
                tempjhnfkajn += Math.sqrt(Math.abs(Math.pow(pts[i+1][0]-pts[i][0],2)) + Math.abs(Math.pow(pts[i+1][1]-pts[i][1],2)));
              }
            }// for end
            let rise = (pts[between[1]][1] - pts[between[0]][1]) / (Math.abs(pts[between[1]][1] - pts[between[0]][1]) + Math.abs(pts[between[1]][0] - pts[between[0]][0]));
            let run = (pts[between[1]][0] - pts[between[0]][0]) / (Math.abs(pts[between[1]][1] - pts[between[0]][1]) + Math.abs(pts[between[1]][0] - pts[between[0]][0]));
            let change = currentDistance - tempjhnfkajn;
            
            let pointx = pts[between[0]][0] + (change*run);
            let pointy = pts[between[0]][1] + (change*rise);
            dbd(pts, colour, currentpoint, pointx, pointy);
        }//func end

        function dbd(pts, colour, current, lastx, lasty){
          if (current > 1){
            currentSectionLength = 1;
          }
          ctx.strokeStyle = colour;
          ctx.lineWidth = defaultBeat.radius*2 + defaultBeat.radius/20;
          ctx.beginPath();
          ctx.moveTo(pts[0][0], pts[0][1]);
          for (i = 0; i < Math.floor(pts.length*current) - 1; i++) {
            ctx.lineTo(pts[i][0], pts[i][1]);
            if( i == Math.floor(pts.length*current) - 2){
              ctx.stroke();
              drawCircle(pts[i][0], pts[i][1], defaultBeat.radius + defaultBeat.radius/20, colour, 0,"rgb(0,0,0,0)", 0, 2);
            }
          }//for end
          drawCircle(pts[0][0], pts[0][1], defaultBeat.radius + defaultBeat.radius/20, colour, 0,"rgb(0,0,0,0)", 0, 2);
        }//func end

        var dragstart = false;
        // var dragstage = 0;

        function dragComplete() {
          console.log('complete!');
          beats.shift();
          dragstart = false;
          score += 5;
          // rememberdragonce = true;
        }


        function beatHitDetect() {
          if (beats[0][0] == 0) {
            if (circlehitboxdetect(beats[0][2][0], beats[0][2][1], mouse[0], mouse[1])) {
              score += (4 - Math.abs(1 - beats[0][1]))
              beats.shift();
            } else {
              score -= 2;
            }
          } else {
            if (circlehitboxdetect(beats[0][3][0][0], beats[0][3][0][1], mouse[0], mouse[1]) && beats[0][1] + failTimer > mapTimer) {
              dragstart = true;
              beats[0][4] = 0;
            } else {
              score -= 2;
            }
          }
        }

        function circlehitboxdetect(x1, y1, x2, y2, radius = defaultBeat.radius) {
          let linelength = Math.sqrt(Math.pow(Math.abs(x1-x2),2) + Math.pow(Math.abs(y1-y2),2));//a2+b2=c2
          if (linelength <= radius) {
            return true;
          } else {
            return false;
          }
        }

        function resizeCanvas() {
          document.getElementById("canvasContainer").style.width = screen.width + "px";
          document.getElementById("canvasContainer").style.height = screen.height + "px";
          canvas.width = canvas.clientWidth;
          canvas.height = canvas.clientHeight;
        }

        function drawCircle(x, y, radius, c, borderwidth, bordercolour, pathstart, pathend) { //pathstart 0 - <2; patheend 0> - 2
          ctx.strokeStyle = bordercolour;
          ctx.lineWidth = borderwidth;
          ctx.fillStyle = c;
          ctx.beginPath();
          ctx.arc(x, y, radius, pathstart * Math.PI, pathend * Math.PI);
          ctx.stroke();
          ctx.fill();
        }

        function colourRect(x, y, w, h, c) {
          ctx.fillStyle = c;
          ctx.fillRect(x, y, w, h)
        }

        function getMousePos(canvas, evt) {
          var rect = canvas.getBoundingClientRect();
          return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
          };
        }
      </script>
    </canvas>
  </div>
</body>

</html>

<style>
  div {
    width: 1920px;
    height: 1920px;
    position: relative;
  }

  canvas {
    position: absolute;
    padding: 0;
    margin: 0;
    width: 100%;
    height: 100%;
  }

  * {
    margin: 0;
    padding: 0;
  }

  html {
    overflow-y: hidden;
    background-color: rgb(40, 40, 40, 1);
  }

  button {
    width: 100vw;
    height: 50vh;
    margin-bottom: 50vw;
    font-size: 5vw;
    color: rgb(255, 255, 255, 1);
    background-color: rgb(60, 60, 60, 1);
  }
</style>
